# 第五章 死锁

## 第一节 死锁的产生

### 一、死锁的定义

​		指在多道程序系统中，一组进程中的每一个进程均无限期的等待被该组进程中的了另一个进程所占用且永远不会释放的资源。

​		处于死锁状态的进程称为死锁进程。

### 二、死锁产生的原因

#### 1、资源的概念

1. 永久性资源(可重用资源)

   如内存、外部设备、处理器等硬件资源。

   各种数据文件、表格、共享程序代码等软件资源。

2. 临时性资源(消耗性资源)

   指由某个进程产生、只为另一个进程使用一次或经过短暂时间后便不在使用的资源。

   如I/O和时钟中断信号、同步信号、消息等。

#### 2、产生死锁的原因

1. 竞争资源

   系统在资源分配时出现失误、进程间对资源相互争夺而造成僵局。

2. 进程推进顺序不合理

#####  1、申请不同类资源产生死锁

1. 进程`P1`和`P2`在运行中使用输入、输出设备，假定系统中只有一台输入设备和一台输出设备，则进程`P1`和`P2`可有如下形势：

![](F:\自考\操作系统\img\2020-05-19_162528.jpg)

如果进程交替执行，如下：

* `P1`：申请一台输入设备
* `P2`：申请一台输出设备
* `P1`：申请一台输出设备
* `P2`：申请一台输入设备

![](F:\自考\操作系统\img\2020-05-19_162836.jpg)

##### 2、申请同类资源产生死锁

假设有一类可重用资源R，如内存，它包含m个页面，由n个进程`P1`、`P2`，...，`Pn(2<=m<=n)`共享。假定每个进程按下述顺序依次申请和释放页面：

1. 申请一个页面
2. 申请一个页面
3. 释放一个页面
4. 释放一个页面

n=3, m=2的情况

![](F:\自考\操作系统\img\2020-05-19_163640.jpg)

##### 3、P、V操作使用不当产生的死锁

​		对于第四章 生产者---消费者问题，如果把`P(mutex)`放在`P(empty)`和`P(Full)`之前，就会产生死锁

考虑当：

* empty=0， full = n 的情况

  第一种情况：假设生产者进程占有处理器，此时，执行完`P(mutex)`,在执行`P(empty)`时，生产者进程阻塞，让出处理器，消费者进程执行`P(mutex)`也会阻塞，此时产生死锁。

* empty=n， full = 0 的情况

  第二种情况：假设消费者进程占有处理器，此时，执行完`P(mutex)`,在执行`P(full)`时，消费者进程阻塞，让出处理器，生产者进程执行`P(mutex)`也会阻塞，此时产生死锁。

##### 4、对临时性资源的使用不加限制产生死锁

​		在进程通信时使用的信件可以看做是一种临时性资源，如果对信件的发送和接收不加限制，则可能引起死锁

​		比如，进程`P1`等待进程`P3`的信件`S3`，`S3`到来后再向进程`P2`发送信件`S1`，`P2`又要等待`P1`的信件`S1`到来后在向`P3`发送信件`S2`，`P3`进程也要等待进程`P2`的信件`S2`到来后才能发送信件`S3`。

|                                                 |                                                 |
| ----------------------------------------------- | ----------------------------------------------- |
| ![](F:\自考\操作系统\img\2020-05-19_170628.jpg) | ![](F:\自考\操作系统\img\2020-05-19_171000.jpg) |

##### 5、对临时性资源的使用不加限制产生死锁 --不产生死锁

|                                                 |                                                 |
| ----------------------------------------------- | ----------------------------------------------- |
| ![](F:\自考\操作系统\img\2020-05-19_171232.jpg) | ![](F:\自考\操作系统\img\2020-05-19_171000.jpg) |

### 三、产生死锁的四个必要条件

对于永久性资源，产生死锁的四个必要条件：

- 互斥条件
- 不可剥夺条件
- 请求和保持条件
- 循环等待条件

### 四、解决死锁的方法

- 预防死锁
- 避免死锁
- 检测与解除死锁
- 忽略死锁

## 第二节 死锁预防

### 一、死锁预防的概念

* 死锁预防

  是指在任何系统操作前(如分配资源、调度进程等)，事先评估系统的可能情况，严格采取措施，使得产生死锁的四个必要条件不成立

* 基本思想

  防患于未然

* 具体做法

  破坏产生死锁的四个必要条件之一

### 二、静态资源分配策略

* 分配原则：

  一个进程在申请新资源的要求得不到满足时，便处于等待状态，而处于等待状态的进程的全部资源可以被剥夺。

  两个策略：

  * 破坏不可剥夺条件
  * 破坏请求和保持条件

#### 1、破坏不可剥夺条件

两种方法：

* 若一个进程已占用了某些资源，又要申请新的资源，在得不到新资源的同时释放原有资源，然后等待。
* 若一个进程申请新资源，首先系统检查该资源是否可用，如果可用则分配，否则从其他等待进程剥夺资源分配给该进程，如果没有等待进程占有该资源，该进程必须等待，在等待过程中，资源也可能被剥夺。

#### 2、破坏请求和保持条件

方法：

​		每个进程必须在开始执行前就申请它所需要的全部资源，仅当系统能满足进程的资源请求且把资源一次性分配给进程后，该进程才能开始执行。

### 三、资源有序分配法

- 策略：

​		破坏循环等待条件

- 方法：

​		对系统所有资源类型进行线性排序，并赋予不同的序号。进程申请资源时，必须严格按照资源编号的顺序进行。即一个进程先得到编号小的资源，才能申请编号大的资源。释放资源时，次序相反。

- 一般原则：

​		较为紧缺、稀少的资源的编号较大。

- 破坏循环等待条件

​		比如，令输入及的序号为1，打印机的序号为2，磁带机为3，磁盘为4。所有进程对资源是请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“循环等待”条件。

## 第三节 死锁避免

前面讨论的死锁预防策略，总体上是增强了较强的限制条件，从而使实现较为简单，但却严重地影响了系统性能。

### 一、死锁避免的概念

#### 1、基本思想

系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统不会发生死锁，则予以分配，否则，不予分配。

#### 2、和死锁预防的区别

死锁预防的是破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。而死锁避免是在系统运行过程中注意避免死锁的发生，即使死锁的必要条件存在，也不一定发生死锁。

### 二、安全状态与安全序列

#### 1、安全状态

如果操作系统能够保证所有的进程在有限时间内得到所需的全部资源，则称系统处于“安全状态”，否则说系统是不安全的。

判断：如果存在一个由系统中所有进程构成的安全序列{`P1`、`P2`，....，`Pn`}，则系统处于安全状态。

#### 2、安全序列

​	系统能按某种进程推进顺序{`P1`、`P2`，....，`Pn`},为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序的完成。此时称{`P1`、`P2`，....，`Pn`}为安全序列。

#### 3、安全状态与不安全状态的关系

系统中不存在安全序列，则称系统为不安全状态

#### 4、安全状态与不安全状态的关系图

![](F:\自考\操作系统\img\2020-05-20_103017.jpg)

#### 5、例题1

​		现有12个同类资源供3个进程共享，进程`P1`总共需要9个资源，但第一次先申请2个；进程`P2`总共需要10个资源，第一次要求分配5个资源；`P3`总共需要4个资源，第一次请求2个资源。经过第一次分配后，系统还有3个资源未分配。

![](F:\自考\操作系统\img\2020-05-20_104505.jpg)

该状态是否安全？

存在安全序列{`P1`，`P2`，`P3`}，该状态安全。

#### 6、例题2

若进程`P1`提出再申请一个资源的要求，系统从剩余资源中分配1个给`P1`后剩余2个

![](F:\自考\操作系统\img\2020-05-20_111735.jpg)

该状态不安全，找不到安全序列。

### 三、银行家算法

由Dijkstra发明

原意：

- 确保银行在发放现金贷款时，不会发生满足所有客户需要的情况

操作系统中：

- 保证系统不会进入不安全状态的算法
- 下面举例说明银行家算法的资源分配算法。

示例1：

假定系统中有五个进程{`P1`，`P2`，`P3`，`P4`，`P5`}和三类资源{ A，B，C }，各种资源的数量分别为10、5、7，资源分配境况如图所示。

![](F:\自考\操作系统\img\2020-05-20_113217.jpg)

存在安全序列{`P2`，`P4`，`P5`，`P1`，`P3`}，该状态安全。

示例2：

在示例一状态下，进程`P2`又提出请求(1,0,2),此时状态如图

![](F:\自考\操作系统\img\2020-05-20_114430.jpg)

在此状态下，系统剩余资源不能满足任何进程的要求，`P2`的请求不予满足，`P2`等待

## 第四节 死锁的检测与解除

### 一、死锁的检测和解除

假如系统为进程分配资源时，不采取任何限制性措施来避免和预防死锁，而是在操作系统运行过程中，不断的监督程序的执行和资源的占用情况，判断是否发生死锁，一旦发生死锁，采取专门的措施解除死锁，并以最小代价使系统恢复正常。

### 二、死锁检测时机

* 检测的实质：

  检测算法检测是否存在"循环条件"条件

- 时机：
  - 一次资源分配后
  - 每次调度后
  - 定时器定时运行检测程序
  - 当某个进程长期处于阻塞状态或阻塞状态程序过多时

- 算法规则

  当任一进程`Pj`申请一个已经被占用的资源`Ri`时，进行死锁检测，反复查找资源分配表和等待进程表，来确定`Pj`对资源`Ri`的请求是否形成环路，若是，出现死锁。

![](F:\自考\操作系统\img\2020-05-20_130746.jpg)

### 三、解除死锁的方法

1. 剥夺资源

   一旦发生死锁，挂起一些进程，剥夺他们占有的资源给死锁进程，以解除死锁

2. 撤销进程

   撤销部分死锁进程，将他们占有的资源分配给另一些死锁进程，直到死锁解除为止。

   可以一次撤销所有死锁进程，也可以逐个撤销。

## 第五节 资源分配图

### 一、资源分配图

1. 作用

   描述系统中资源分配和申请情况，对死锁进行分析并采取对策

2. `SRAG`定义

   是一张有向图，可定义为一个二元组，即，`SRAG`=(V,E)，其中V是顶点的集合，包括进程集合、资源集合，E是有向边的集合，是一个有序对<`Pi`, `ri`>

![](F:\自考\操作系统\img\2020-05-20_132352.jpg)

### 二、死锁定理

1. 作用

   判定死锁的法则

2. 死锁定理
   - 如果资源配图中没有环路，则系统无死锁
   - 如果资源分配图中出现了环路，则可能存在死锁
   - 如果处于环路中的每个资源类中均包含一个资源实例，则环路存在意味着死锁的存在。此时，环路是死锁的充分必要条件。

![](F:\自考\操作系统\img\2020-05-20_135439.jpg)

- 如果处于环路中的每个资源类中实例的个数不全为1，则环路存在是死锁的必要条件而非充分条件。

  - 存在两个环路`p1 - r1 - p2 - r2 - p3 - r3 - p1`,环路`p2 - r2 - p3 - r3 - p2`。`p1,p2,p3`都陷入了死锁。

    ![](F:\自考\操作系统\img\2020-05-20_135814.jpg)

  - 存在环路`p1 - r1 - p3 - r2 - p1`, 但无死锁。

    ![](F:\自考\操作系统\img\2020-05-20_135955.jpg)

### 三、资源分配图简化方法

可以使用资源分配图简化方法，来检测系统是否为死锁状态。步骤如下：

* (1) 在资源分配图中，找出一个既不阻塞又非独立的进程结束Pi。在顺利的情况下，Pi可获得所需资源而继续运行，直至运行完毕，在释放其所占的全部资源，这相当于消去pi的请求边和分配边，使之称为孤立的结点。

* (2) 将Pi释放的资源分配给申请它的进程，若该进程能顺利运行完，释放资源，再次成为孤立结点。

* (3) 重复(1)、（2），直到找不到符合条件的进程节点。

  经过简化后，若能消去所有的边，则该图完全简化，系统不存在死锁；否则不可能完全简化，存在死锁。

## 第六节 哲学家就餐问题

### 1、描述

- 有五个哲学家围在一个圆桌旁，每人面前有一只碗，碗里有有面条，每两人之间放一只筷子
- 每个哲学家的行为是思考，感到饥饿，然后吃饭。
- 为了吃饭，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左边或者右边去去筷子。

### 2、算法描述

- 为每个筷子设置一个互斥型信号量

  semaphore chopstick[5] = {1,1,1,1,1}

```
do {
	P(chopstick[i]); // 拿左筷子
	P(chopstick[(i+1)%5]); // 拿右筷子
	...
	eat;
	...
	V(chopstick[i]); // 放左筷子
	V(chopstick[(i+1)%5]); // 放右筷子
	...
	think;
}while(TRUE);
```

### 3、存在问题

死锁

### 4、改进

采用资源有序分配算法，给每个筷子编号，规定每个哲学家先拿编号小的筷子再拿编号大的筷子。哲学家i（1<=i<=4）不变，第五个哲学家的程序改进如下：

```
do {
	P(chopstick[i]); // 拿左筷子
	P(chopstick[5]); // 拿右筷子
	...
	eat;
	...
	V(chopstick[i]); // 放左筷子
	V(chopstick[5]); // 放右筷子
	...
	think;
}while(TRUE);
```

